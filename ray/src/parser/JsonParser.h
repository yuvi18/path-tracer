#pragma once
#pragma warning(disable : 4786)

/*
This is the parser for the new JSON format which was generated by using the
Rust rayfile translator. Full documentation of the format can be found in
jsonformat.md

The JSON parser is much simpler to understand than the rayfile parser,
since much of the heavy lifting is done by the nlohmann JSON library.
The tradeoff is that error messages are worse, since we lose track of line
numbers once the JSON is fully parsed. The JSON error messages attempt to
give some context (like keys in the object that's failing to parse), but
if you get a baffling error message, I suggest running under a debugger
and backtracing to the error frame, then printing the JSON object to
see what's going wrong. */

#include <map>
#include <string>

#include <filesystem>
#include <fstream>
#include <optional>
#include <sstream>

#include <glm/vec3.hpp>
#include <glm/vec4.hpp>

#include <json.hpp>
using json = nlohmann::json;

#include "../SceneObjects/Box.h"
#include "../SceneObjects/Cone.h"
#include "../SceneObjects/Cylinder.h"
#include "../SceneObjects/Sphere.h"
#include "../SceneObjects/Square.h"
#include "../SceneObjects/trimesh.h"
#include "../scene/light.h"
#include "../scene/scene.h"

typedef std::map<string, Material> mmap;

/* While parsing, we need to track certain data, such as the current
scene, the directory of the scene file (for loading textures + cubemaps),
the stack of transforms that is currently active, and the last material
specified at the top-level of the file (which overrides material defaults
for all objects that come after it). Since this data is only needed while
parsing and not afterwards, we store it in a struct which is threaded
through all parsing functions by reference. This does preclude
multithreaded parsing, but the file format inherently puts a cap on that. */
struct ParseData {
  Material cur_mat;
  std::vector<glm::dmat4> transformStack;
  Scene *s;
  std::filesystem::path scene_dir;

  glm::dmat4 getCurrentTransform();
};

Camera parseCamera(const json &j);
MaterialParameter parseMaterialParameter(const json &j, ParseData &pd);
Material parseMaterial(const json &j, ParseData &pd);

/* Because the Scene manages Lights and Geometry lifetimes (calling delete when
the Scene is dropped), we allocate our lights as raw pointers with new and
pass those pointers into the Scene. AmbientLight is weird because it's not
actually a light (see comments in scene.h for details) */

DirectionalLight *parseDirectionalLight(const json &j);
PointLight *parsePointLight(const json &j);
glm::dvec3 parseAmbientLight(const json &j);

Sphere *parseSphereBody(const json &j, ParseData &pd);
Box *parseBoxBody(const json &j, ParseData &pd);
Square *parseSquareBody(const json &j, ParseData &pd);
Cylinder *parseCylinderBody(const json &j, ParseData &pd);
Cone *parseConeBody(const json &j, ParseData &pd);
Trimesh *parseTrimeshBody(const json &j, ParseData &pd);
std::vector<Trimesh *> parseObjmeshBody(const json &j, ParseData &pd);
std::vector<Geometry *> parseGeometry(const json &j, ParseData &pd);

std::vector<Geometry *> parseTransform(const json &j, ParseData &pd);
std::vector<Geometry *> parseGeometryOrTransform(const json &j, ParseData &pd);

class JsonParser {
public:
  JsonParser(std::string pathToJson, std::ifstream &ifs)
      : fileDirPath(pathToJson) {
    std::ostringstream sstr;
    sstr << ifs.rdbuf();
    this->contents = sstr.str();
  };

  Scene *parseScene();

private:
  std::string contents;
  std::string fileDirPath;
};